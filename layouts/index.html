{{ define "main" }} {{/* Load all company pages and computed data */}} {{-
$computed := .Site.Data.computed -}} {{- $companies := slice -}} {{- range where
.Site.RegularPages "Section" "company" -}} {{- if ne .File.BaseFileName "_template" -}}
{{- $company := .Params -}} {{-
$company = merge $company (dict "slug" .File.BaseFileName) -}} {{- $companies =
$companies | append $company -}} {{- end -}} {{- end -}} {{- $companies = sort $companies
"name" -}} {{- $taxonomies := .Site.Data.taxonomies -}}

<div class="row directory-header">
  <nav aria-label="breadcrumb" class="col-8 col-m-6 col-s-12 directory-breadcrumb">
    <ul>
      <li>Directory</li>
      <li id="breadcrumb-filters" class="hidden">
        <button type="button" class="filter-badge" id="clear-filters">
          <span class="filter-count">0</span> filters ✕
        </button>
      </li>
      <li>
        {{/* aria-live announces count changes to screen readers */}}
        <output id="results-status" aria-live="polite" aria-atomic="true">
          <span class="visible-count">{{ len $companies }}</span> of {{ len $companies }}
        </output>
      </li>
    </ul>
  </nav>
  <div class="col-4 col-m-6 col-s-12">
    <fieldset role="group" class="search-group">
      <input
        type="search"
        name="q"
        form="filters"
        placeholder="Search companies..."
        autocomplete="off"
        aria-label="Search companies"
      >
      <label class="map-toggle" title="Show map">
        <input type="checkbox" id="map-toggle" name="view" value="map" form="filters">
        {{ partial "icon.html" (dict "name" "map" "size" 20) }}
      </label>
    </fieldset>
  </div>
</div>

{{/* Skip link to bypass filters - visible on focus */}}
<a href="#company-grid" class="skip-link">Skip to results</a>

<h1 class="visually-hidden">
  WA Defence Industry and Science Capability Directory
</h1>

<div class="row" id="directory">
  <!-- Mobile filter toggle button -->
  <button type="button" class="mobile-filter-toggle" aria-expanded="false" aria-controls="filters-sidebar">
    {{ partial "icon.html" (dict "name" "filter" "size" 18) }}
    Filters
  </button>

  <!-- Main Content (first in DOM for better tab order: search → results) -->
  <section class="col-9 col-m-8 col-s-12 directory-results">
    <!-- Cards Grid -->
    <div class="grid-auto" id="company-grid" tabindex="-1">
      {{- range $companies }} {{ partial "company-card.html" (dict "company" .
      "computed" (index $computed .slug) "mode" "directory") }} {{- end }}
    </div>

    <!-- Map iframe (hidden by default) -->
    <iframe id="map-iframe" class="hidden" title="Map"></iframe>

    <!-- No results message -->
    <p class="no-results">No companies match your filters.</p>
  </section>
  
  <!-- Filters Sidebar (after results in DOM, positioned left via CSS) -->
  <aside class="col-3 col-m-4 col-s-12 filters-sidebar" id="filters-sidebar">
    <button type="button" class="mobile-filter-close" aria-label="Close filters">
      {{ partial "icon.html" (dict "name" "x" "size" 24) }}
    </button>
    {{ partial "filters.html" (dict "companies" $companies "taxonomies"
    $taxonomies "site" .Site) }}
  </aside>
  
  <!-- Mobile filter backdrop -->
  <div class="mobile-filter-backdrop"></div>
</div>

<noscript>
  <style>
    .clear-all,
    .clear-section {
      display: none !important;
    }
    .no-results {
      display: none !important;
    }
  </style>
</noscript>

<script>
  (function() {
    "use strict";

    // === DOM ===
    const $ = (s) => document.querySelector(s);
    const $$ = (s) => [...document.querySelectorAll(s)];
    const form = $("#filters");
    const cards = $$(".company-item");
    const gridEl = $("#company-grid");
    const mapIframe = $("#map-iframe");
    const countEl = $(".visible-count");
    const filterCountEl = $(".filter-count");
    const breadcrumbFilters = $("#breadcrumb-filters");
    const noResults = $(".no-results");
    const mapToggle = $("#map-toggle");
    const totalCount = cards.length;

    let mapLoaded = false;

    // === Get Filters from Form ===
    function getFilters() {
      const data = new FormData(form);
      return {
        search: (data.get("q") || "").trim().toLowerCase(),
        f: data.getAll("f"),  // All filter values like "st:ai", "cs:base", etc.
      };
    }

    // === Match Card Against Filters ===
    function matchesFilters(dataset, filters) {
      // Search
      if (filters.search) {
        const text = (dataset.search || "").toLowerCase();
        if (!text.includes(filters.search)) return false;
      }

      // Taxonomy filters - card's data-f contains "st:ai|cs:base|..."
      // All selected filters must be present (AND logic)
      if (filters.f.length) {
        const cardFilters = (dataset.f || "").toLowerCase().split("|");
        if (!filters.f.every(f => cardFilters.includes(f.toLowerCase()))) return false;
      }

      return true;
    }

    // === URL Sync ===
    function syncFromURL() {
      const params = new URLSearchParams(location.search);

      // Populate form fields from URL
      for (const input of form.elements) {
        if (input.type === "checkbox") {
          input.checked = params.getAll(input.name).includes(input.value);
        } else if (input.name) {
          input.value = params.get(input.name) || "";
        }
      }

      // Sync map toggle from URL
      if (mapToggle) {
        mapToggle.checked = params.get("view") === "map";
        setView(mapToggle.checked, false);
      }
    }

    function updateURL() {
      const params = new URLSearchParams(new FormData(form));
      if (mapToggle?.checked) params.set("view", "map");
      const url = params.toString() ? "?" + params : location.pathname;
      history.replaceState({}, "", url);
    }

    // === Search Highlighting ===
    function updateHighlight(query) {
      if (!CSS.highlights) return;
      CSS.highlights.clear();
      if (!query) return;

      const ranges = [];
      const q = query.toLowerCase();

      $$(".company-item:not(.filter-hidden) .name").forEach((el) => {
        const textNode = el.firstChild;
        if (!textNode || textNode.nodeType !== Node.TEXT_NODE) return;
        const text = textNode.textContent.toLowerCase();
        const idx = text.indexOf(q);
        if (idx >= 0) {
          try {
            const range = new Range();
            range.setStart(textNode, idx);
            range.setEnd(textNode, idx + q.length);
            ranges.push(range);
          } catch (e) {}
        }
      });

      if (ranges.length) CSS.highlights.set("search-results", new Highlight(...ranges));
    }

    // === Update Display ===
    function updateCards() {
      const filters = getFilters();
      let visibleCount = 0;

      cards.forEach((card) => {
        const visible = matchesFilters(card.dataset, filters);
        card.classList.toggle("filter-hidden", !visible);
        if (visible) visibleCount++;
      });

      if (countEl) countEl.textContent = visibleCount;
      if (noResults && !isMapView()) {
        noResults.style.display = visibleCount === 0 ? "block" : "none";
      }

      // Update filter count in breadcrumb
      const activeFilters = filters.f.length + (filters.search ? 1 : 0);
      if (breadcrumbFilters) {
        breadcrumbFilters.classList.toggle("hidden", activeFilters === 0);
        if (filterCountEl) filterCountEl.textContent = activeFilters;
      }

      updateHighlight(filters.search || "");
    }

    // === Map Communication ===
    function updateMap() {
      if (!isMapView() || !mapLoaded) return;
      const params = new URLSearchParams(new FormData(form)).toString();
      mapIframe.contentWindow?.postMessage({ type: "updateFilters", params }, "*");
    }

    window.addEventListener("message", (e) => {
      if (e.data?.type === "markerCount" && isMapView()) {
        if (countEl) countEl.textContent = e.data.count;
        if (noResults) noResults.style.display = e.data.count === 0 ? "block" : "none";
      }
    });

    // === View Toggle ===
    function isMapView() {
      return mapToggle?.checked;
    }

    function setView(showMap, updateUrl = true) {
      gridEl.classList.toggle("hidden", showMap);
      mapIframe.classList.toggle("hidden", !showMap);

      if (showMap && !mapLoaded) {
        mapIframe.src = "./map/";
        mapLoaded = true;
      }

      if (updateUrl) updateURL();
      showMap ? updateMap() : updateCards();
      if (showMap && noResults) noResults.style.display = "none";
    }

    mapToggle?.addEventListener("change", () => setView(mapToggle.checked));
    mapIframe.addEventListener("load", updateMap);

    // === Event Listeners ===
    function onFilterChange() {
      updateCards();
      updateMap();
      updateURL();
    }

    // Debounced search
    let searchTimeout;
    form.q?.addEventListener("input", () => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(onFilterChange, 150);
    });

    // All other form changes
    form.addEventListener("change", () => {
      onFilterChange();
      updateOptionVisibility();
    });

    // === Filter Options (filters the taxonomy lists) ===
    const filterOptionsInput = $("#filter-options");
    const allFilterItems = $$(".filters .filter-item");
    const allStreamLabels = $$(".filters .stream-icon");
    const allSections = $$(".filters .filter-section");

    function updateOptionVisibility() {
      const query = (filterOptionsInput?.value || "").toLowerCase().trim();

      // Filter checkbox list items (always show checked items)
      allFilterItems.forEach(item => {
        const label = item.querySelector(".filter-label");
        const isChecked = item.querySelector("input")?.checked;
        const matches = !query || (label?.textContent || "").toLowerCase().includes(query);
        item.hidden = !matches && !isChecked;
      });

      // Filter stream icon labels (always show checked items)
      allStreamLabels.forEach(label => {
        const isChecked = label.querySelector("input")?.checked;
        const matches = !query || label.title.toLowerCase().includes(query);
        label.hidden = !matches && !isChecked;
      });

      // Hide sections with no visible items
      allSections.forEach(section => {
        const filterList = section.querySelector(".filter-list");
        const streamIcons = section.querySelector(".stream-icons");

        if (filterList) {
          const hasVisible = [...filterList.querySelectorAll(".filter-item")].some(i => !i.hidden);
          section.hidden = !hasVisible;
        } else if (streamIcons) {
          const hasVisible = [...streamIcons.querySelectorAll(".stream-icon")].some(l => !l.hidden);
          section.hidden = !hasVisible;
        }
      });
    }

    filterOptionsInput?.addEventListener("input", updateOptionVisibility);

    // Also clear filter-options on form reset
    form.addEventListener("reset", () => {
      setTimeout(() => {
        updateOptionVisibility();
        onFilterChange();
      }, 0);
    });

    // Prevent form submission (we use live filtering)
    form.addEventListener("submit", (e) => e.preventDefault());

    window.addEventListener("popstate", () => { syncFromURL(); updateCards(); updateMap(); });

    // === Mobile Filter Toggle (with focus trap for a11y) ===
    const filterToggle = $(".mobile-filter-toggle");
    const filterSidebar = $(".filters-sidebar");
    const filterBackdrop = $(".mobile-filter-backdrop");
    const filterClose = $(".mobile-filter-close");
    let previousActiveElement = null;

    function openFilters() {
      previousActiveElement = document.activeElement;
      filterSidebar?.classList.add("open");
      filterBackdrop?.classList.add("open");
      filterToggle?.setAttribute("aria-expanded", "true");
      document.body.style.overflow = "hidden";
      // Focus first focusable element in sidebar
      const firstFocusable = filterSidebar?.querySelector(
        'input, button, [tabindex]:not([tabindex="-1"])'
      );
      firstFocusable?.focus();
    }

    function closeFilters() {
      filterSidebar?.classList.remove("open");
      filterBackdrop?.classList.remove("open");
      filterToggle?.setAttribute("aria-expanded", "false");
      document.body.style.overflow = "";
      // Return focus to toggle button
      previousActiveElement?.focus();
    }

    filterToggle?.addEventListener("click", openFilters);
    filterClose?.addEventListener("click", closeFilters);
    filterBackdrop?.addEventListener("click", closeFilters);

    // Focus trap - keep Tab within sidebar when open
    filterSidebar?.addEventListener("keydown", (e) => {
      if (e.key !== "Tab" || !filterSidebar.classList.contains("open")) return;
      const focusables = [...filterSidebar.querySelectorAll(
        'input:not([type="hidden"]), button, [tabindex]:not([tabindex="-1"])'
      )].filter(el => !el.hidden && !el.disabled);
      if (!focusables.length) return;
      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      if (e.shiftKey && document.activeElement === first) {
        e.preventDefault();
        last.focus();
      } else if (!e.shiftKey && document.activeElement === last) {
        e.preventDefault();
        first.focus();
      }
    });

    // === Clear Filters Badge ===
    const clearFiltersBtn = $("#clear-filters");
    clearFiltersBtn?.addEventListener("click", () => {
      // Uncheck all filter checkboxes (but not the view switch)
      form.querySelectorAll('input[name="f"]:checked').forEach(cb => cb.checked = false);
      // Clear search
      if (form.q) form.q.value = "";
      onFilterChange();
      updateOptionVisibility();
    });

    // === Keyboard Shortcuts (a11y) ===
    document.addEventListener("keydown", (e) => {
      // '/' to focus search (like GitHub)
      if (e.key === "/" && !e.target.matches("input, textarea, select")) {
        e.preventDefault();
        form.q?.focus();
      }
      // Escape to close mobile filter panel or clear search
      if (e.key === "Escape") {
        if (filterSidebar?.classList.contains("open")) {
          closeFilters();
        } else if (form.q?.value) {
          form.q.value = "";
          onFilterChange();
        }
      }
    });

    // === Icon Filter Keyboard Navigation (a11y) ===
    // Make stream icons keyboard accessible with Enter/Space
    allStreamLabels.forEach(label => {
      const checkbox = label.querySelector('input[type="checkbox"]');
      if (!checkbox) return;
      // Set initial ARIA state
      label.setAttribute("role", "checkbox");
      label.setAttribute("aria-checked", checkbox.checked);
      label.setAttribute("tabindex", "0");
      checkbox.setAttribute("tabindex", "-1"); // Hide from tab order
      // Handle keyboard activation
      label.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          checkbox.checked = !checkbox.checked;
          label.setAttribute("aria-checked", checkbox.checked);
          checkbox.dispatchEvent(new Event("change", { bubbles: true }));
        }
      });
      // Sync ARIA state when checkbox changes
      checkbox.addEventListener("change", () => {
        label.setAttribute("aria-checked", checkbox.checked);
      });
    });

    // === Init ===
    syncFromURL();
    updateCards();
    // Sync ARIA states after URL sync
    allStreamLabels.forEach(label => {
      const checkbox = label.querySelector('input[type="checkbox"]');
      if (checkbox) label.setAttribute("aria-checked", checkbox.checked);
    });
  })();
</script>

{{ end }}
