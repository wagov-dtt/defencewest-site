---
import Layout from "../layouts/Layout.astro";
import CompanyCard from "../components/CompanyCard.astro";
import MapPopup from "../components/MapPopup.astro";
import { getCollection } from "astro:content";
import { getTaxonomies, getStreamIcons } from "../lib/taxonomies";
import type { Company } from "../content.config";

// Load companies from Content Collection
const companyEntries = await getCollection("companies");
const companies: Company[] = companyEntries
  .map((entry) => entry.data)
  .sort((a, b) => a.name.localeCompare(b.name));

// Companies with coordinates for the map
const mappedCompanies = companies.filter((c) => c.latitude && c.longitude);

// Load taxonomies
const taxonomies = getTaxonomies();
const streamIcons = getStreamIcons();

// Count companies per taxonomy value
function countByTaxonomy(field: keyof Company): Map<string, number> {
  const counts = new Map<string, number>();
  companies.forEach((c) => {
    const values = (c[field] as string[] | undefined) || [];
    values.forEach((val: string) => {
      counts.set(val, (counts.get(val) || 0) + 1);
    });
  });
  return counts;
}

const stakeholderCounts = countByTaxonomy("stakeholders");
const streamCounts = countByTaxonomy("capability_streams");
const domainCounts = countByTaxonomy("capability_domains");
const industrialCounts = countByTaxonomy("industrial_capabilities");
const regionCounts = countByTaxonomy("regions");

// Prepare marker data for map (coordinates only, popup HTML is in DOM)
const markers = mappedCompanies.map((c) => ({
  slug: c.slug,
  coords: [c.longitude, c.latitude],
}));

// Prepare search data for companies
const searchData = companies.map((c) => ({
  slug: c.slug,
  name: c.name,
  overview: c.overview || "",
  capabilities: [
    ...(c.capability_streams || []),
    ...(c.capability_domains || []),
    ...(c.industrial_capabilities || []),
  ].join(" "),
}));

// Prepare filter suggestions (all taxonomy terms with counts)
const filterSuggestions = [
  ...taxonomies.stakeholders.map((t: string) => ({ 
    term: t, param: "stakeholders", count: stakeholderCounts.get(t) || 0 
  })),
  ...Object.keys(taxonomies.capability_streams).map((t: string) => ({ 
    term: t, param: "capability_streams", count: streamCounts.get(t) || 0 
  })),
  ...taxonomies.capability_domains.map((t: string) => ({ 
    term: t, param: "capability_domains", count: domainCounts.get(t) || 0 
  })),
  ...taxonomies.industrial_capabilities.map((t: string) => ({ 
    term: t, param: "industrial_capabilities", count: industrialCounts.get(t) || 0 
  })),
  ...taxonomies.regions.map((t: string) => ({ 
    term: t, param: "regions", count: regionCounts.get(t) || 0 
  })),
].filter(s => s.count > 0);
---

<Layout title="WA Defence Industry and Science Capability Directory">
  <div class="directory-layout">
    <!-- Filters Sidebar -->
    <aside>
      <!-- Active Filters & Count Card -->
      <article class="filter-status-card">
        <p>
          <strong id="result-count">{companies.length}</strong> of {
            companies.length
          } companies
        </p>
        <div id="active-filters-container"></div>
      </article>

      <!-- Capability Streams with icons -->
      <details open>
        <summary>Capability Streams</summary>
        <div class="stream-icons">
          {
            Object.entries(streamIcons).map(([name, icon]) => {
              const count = streamCounts.get(name) || 0;
              if (count === 0) return null;
              return (
                <a
                  href={`/?capability_streams=${encodeURIComponent(name)}`}
                  title={name}
                >
                  <img src={`${icon as string}`} alt={name} />
                </a>
              );
            })
          }
        </div>
      </details>

      <details>
        <summary>Stakeholders</summary>
        <ul>
          {
            taxonomies.stakeholders.map((name: string) => {
              const count = stakeholderCounts.get(name) || 0;
              if (count === 0) return null;
              return (
                <li>
                  <a href={`/?stakeholders=${encodeURIComponent(name)}`}>
                    {name} <small>({count})</small>
                  </a>
                </li>
              );
            })
          }
        </ul>
      </details>

      <details>
        <summary>Capability Domains</summary>
        <ul>
          {
            taxonomies.capability_domains.map((name: string) => {
              const count = domainCounts.get(name) || 0;
              if (count === 0) return null;
              return (
                <li>
                  <a href={`/?capability_domains=${encodeURIComponent(name)}`}>
                    {name} <small>({count})</small>
                  </a>
                </li>
              );
            })
          }
        </ul>
      </details>

      <details>
        <summary>Industrial Capabilities</summary>
        <ul>
          {
            taxonomies.industrial_capabilities.map((name: string) => {
              const count = industrialCounts.get(name) || 0;
              if (count === 0) return null;
              return (
                <li>
                  <a
                    href={`/?industrial_capabilities=${encodeURIComponent(name)}`}
                  >
                    {name} <small>({count})</small>
                  </a>
                </li>
              );
            })
          }
        </ul>
      </details>

      <details>
        <summary>Regions</summary>
        <ul>
          {
            taxonomies.regions.map((name: string) => {
              const count = regionCounts.get(name) || 0;
              if (count === 0) return null;
              return (
                <li>
                  <a href={`/?regions=${encodeURIComponent(name)}`}>
                    {name} <small>({count})</small>
                  </a>
                </li>
              );
            })
          }
        </ul>
      </details>
    </aside>

    <!-- Main Content -->
    <main>
      <input id="search-input" type="search" placeholder="Search companies..." autocomplete="off" />

      <div id="company-grid" class="company-grid" data-pagefind-ignore="all">
        {
          companies.map((company) => (
            <div
              class="company-item"
              data-slug={company.slug}
              data-stakeholders={JSON.stringify(company.stakeholders || [])}
              data-capability-streams={JSON.stringify(
                company.capability_streams || [],
              )}
              data-capability-domains={JSON.stringify(
                company.capability_domains || [],
              )}
              data-industrial-capabilities={JSON.stringify(
                company.industrial_capabilities || [],
              )}
              data-regions={JSON.stringify(company.regions || [])}
            >
              <CompanyCard company={company} />
            </div>
          ))
        }
      </div>

      <div id="map-host" class="hidden"></div>
      <p id="no-results" class="hidden">
        No companies match your search criteria.
      </p>
    </main>
  </div>

  <!-- Pre-rendered map popups (hidden, cloned by JS) -->
  <div id="map-popups" style="display: none;">
    {
      mappedCompanies.map((company) => (
        <template data-slug={company.slug}>
          <MapPopup company={company} />
        </template>
      ))
    }
  </div>

  <!-- Anchor for map navigation -->
  <div id="map"></div>
</Layout>

<script type="module" define:vars={{ markers, searchData, filterSuggestions }}>
  import autoComplete from "https://esm.sh/@tarekraafat/autocomplete.js@10";
  import uFuzzy from "https://esm.sh/@leeoniya/ufuzzy@1";

  window.mapMarkers = markers;

  const grid = document.getElementById("company-grid");
  const mapHost = document.getElementById("map-host");
  const resultCount = document.getElementById("result-count");
  const noResults = document.getElementById("no-results");
  const popupTemplates = document.getElementById("map-popups");
  const allCards = Array.from(document.querySelectorAll(".company-item"));
  const searchInput = document.getElementById("search-input");

  // Taxonomy filter map: URL param -> data attribute
  const taxonomyMap = {
    stakeholders: "stakeholders",
    capability_streams: "capabilityStreams",
    capability_domains: "capabilityDomains",
    industrial_capabilities: "industrialCapabilities",
    regions: "regions",
  };

  // Initialize uFuzzy for company search (with typo tolerance)
  const uf = new uFuzzy({ intraMode: 1 });
  const searchStrings = searchData.map(d => 
    `${d.name} ${d.overview} ${d.capabilities}`.toLowerCase()
  );

  // Initialize uFuzzy for filter suggestions (with typo tolerance)
  const ufFilters = new uFuzzy({ intraMode: 1 });
  const filterStrings = filterSuggestions.map(s => s.term.toLowerCase());

  // Map state
  let map = null;
  let mapMarkerObjects = [];

  // Track current filter matches for autocomplete
  let currentFilterMatches = [];

  // Initialize autoComplete.js for filter term suggestions
  new autoComplete({
    selector: "#search-input",
    data: {
      src: () => currentFilterMatches,
      keys: ["term"],
    },
    searchEngine: (query, record) => {
      // Just return the term - filtering is done in data.src
      return record;
    },
    resultItem: {
      element: (item, data) => {
        item.innerHTML = `<span>${data.value.term}</span> <small>(${data.value.count})</small>`;
      },
    },
    events: {
      input: {
        focus: () => {
          // Update matches on focus too
          const query = searchInput.value;
          if (query && query.length >= 2) {
            const [idxs] = ufFilters.search(filterStrings, query.toLowerCase());
            currentFilterMatches = idxs ? idxs.slice(0, 8).map(i => filterSuggestions[i]) : [];
          }
        },
        selection: (event) => {
          const selection = event.detail.selection.value;
          // Apply as filter
          searchInput.value = "";
          searchInput.blur();
          const dataAttr = taxonomyMap[selection.param];
          const newFilter = { param: selection.param, dataAttr, value: selection.term };
          const currentFilters = getUrlFilters();
          const exists = currentFilters.some(f => f.param === newFilter.param && f.value === newFilter.value);
          if (!exists) currentFilters.push(newFilter);
          updateUrl(currentFilters);
          applyFilters(currentFilters);
        },
      },
    },
  });

  // Also filter grid on input and update autocomplete matches
  let debounceTimer;
  searchInput.addEventListener("input", () => {
    const query = searchInput.value;
    // Update filter matches for autocomplete
    if (query && query.length >= 2) {
      const [idxs] = ufFilters.search(filterStrings, query.toLowerCase());
      currentFilterMatches = idxs ? idxs.slice(0, 8).map(i => filterSuggestions[i]) : [];
    } else {
      currentFilterMatches = [];
    }
    // Debounce the grid filtering
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => doSearch(query), 150);
  });

  // URL helpers
  function getUrlFilters() {
    const params = new URLSearchParams(window.location.search);
    const filters = [];
    for (const [param, dataAttr] of Object.entries(taxonomyMap)) {
      const values = params.getAll(param);
      values.forEach((value) => {
        if (value) filters.push({ param, dataAttr, value });
      });
    }
    return filters;
  }

  function getUrlQuery() {
    return new URLSearchParams(window.location.search).get("q") || "";
  }

  function updateUrl(filters, query = "") {
    const params = new URLSearchParams();
    if (query) params.set("q", query);
    filters.forEach((f) => params.append(f.param, f.value));
    const newUrl = params.toString()
      ? `${window.location.pathname}?${params.toString()}`
      : window.location.pathname;
    window.history.pushState({}, "", newUrl);
  }

  // Highlighting
  function highlightText(text, query) {
    if (!query || query.length < 2) return text;
    const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")})`, "gi");
    return text.replace(regex, "<mark>$1</mark>");
  }

  function clearHighlights() {
    allCards.forEach((card) => {
      const nameEl = card.querySelector("h4");
      const overviewEl = card.querySelector("p");
      if (nameEl?.dataset.original) nameEl.innerHTML = nameEl.dataset.original;
      if (overviewEl?.dataset.original) overviewEl.innerHTML = overviewEl.dataset.original;
    });
  }

  function applyHighlights(query, matchingSlugs) {
    if (!query || query.length < 2) {
      clearHighlights();
      return;
    }
    allCards.forEach((card) => {
      const slug = card.dataset.slug;
      const nameEl = card.querySelector("h4");
      const overviewEl = card.querySelector("p");
      if (nameEl && !nameEl.dataset.original) nameEl.dataset.original = nameEl.textContent;
      if (overviewEl && !overviewEl.dataset.original) overviewEl.dataset.original = overviewEl.textContent;
      if (matchingSlugs.has(slug)) {
        if (nameEl) nameEl.innerHTML = highlightText(nameEl.dataset.original, query);
        if (overviewEl) overviewEl.innerHTML = highlightText(overviewEl.dataset.original, query);
      } else {
        if (nameEl) nameEl.innerHTML = nameEl.dataset.original;
        if (overviewEl) overviewEl.innerHTML = overviewEl.dataset.original;
      }
    });
  }

  // Filtering
  function applyFilters(filters) {
    clearHighlights();
    if (filters.length === 0) {
      allCards.forEach((card) => card.classList.remove("hidden"));
      updateResultCount(allCards.length);
      updateMapMarkers(new Set(allCards.map((c) => c.dataset.slug)));
      updateFilterDisplay(filters);
      return;
    }
    let visibleCount = 0;
    const visibleSlugs = new Set();
    allCards.forEach((card) => {
      const matches = filters.every((filter) => {
        const values = JSON.parse(card.dataset[filter.dataAttr] || "[]");
        return values.includes(filter.value);
      });
      card.classList.toggle("hidden", !matches);
      if (matches) {
        visibleCount++;
        visibleSlugs.add(card.dataset.slug);
      }
    });
    updateResultCount(visibleCount);
    updateMapMarkers(visibleSlugs);
    updateFilterDisplay(filters);
  }

  function updateFilterDisplay(filters) {
    const filterContainer = document.getElementById("active-filters-container");
    if (!filterContainer) return;
    if (filters.length > 0) {
      filterContainer.innerHTML =
        filters.map((f, i) => `<mark class="filter-tag" role="button" data-index="${i}">${f.value} Ã—</mark>`).join("") +
        `<a href="#" id="clear-all-filters" class="secondary">Clear all</a>`;
      filterContainer.querySelectorAll("mark[data-index]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const newFilters = filters.filter((_, i) => i !== parseInt(btn.dataset.index));
          updateUrl(newFilters);
          applyFilters(newFilters);
        });
      });
      document.getElementById("clear-all-filters")?.addEventListener("click", (e) => {
        e.preventDefault();
        updateUrl([]);
        applyFilters([]);
      });
    } else {
      filterContainer.innerHTML = "";
    }
  }

  // Filter link clicks
  document.querySelectorAll('aside a[href*="?"]').forEach((link) => {
    link.addEventListener("click", (e) => {
      e.preventDefault();
      const href = link.getAttribute("href");
      const linkParams = new URLSearchParams(href.split("?")[1] || "");
      let newFilter = null;
      for (const [param, dataAttr] of Object.entries(taxonomyMap)) {
        const value = linkParams.get(param);
        if (value) {
          newFilter = { param, dataAttr, value };
          break;
        }
      }
      if (newFilter) {
        searchInput.value = "";
        clearHighlights();
        const currentFilters = getUrlFilters();
        const exists = currentFilters.some((f) => f.param === newFilter.param && f.value === newFilter.value);
        if (!exists) currentFilters.push(newFilter);
        updateUrl(currentFilters);
        applyFilters(currentFilters);
      }
    });
  });

  // Search
  function doSearch(query, updateHistory = true) {
    if (query.trim() && updateHistory) {
      updateUrl([], query);
      updateFilterDisplay([]);
    } else if (!query.trim() && updateHistory) {
      updateUrl([]);
    }
    if (!query.trim()) {
      clearHighlights();
      const filters = getUrlFilters();
      if (filters.length > 0) {
        applyFilters(filters);
        return;
      }
      allCards.forEach((card) => card.classList.remove("hidden"));
      updateResultCount(allCards.length);
      updateMapMarkers(new Set(allCards.map((c) => c.dataset.slug)));
      return;
    }
    // Use uFuzzy for grid filtering too
    const [idxs] = uf.search(searchStrings, query.toLowerCase());
    const matchingSlugs = new Set(idxs ? idxs.map(i => searchData[i].slug) : []);
    allCards.forEach((card) => {
      card.classList.toggle("hidden", !matchingSlugs.has(card.dataset.slug));
    });
    applyHighlights(query, matchingSlugs);
    updateResultCount(matchingSlugs.size);
    updateMapMarkers(matchingSlugs);
  }

  function updateResultCount(count) {
    if (resultCount) resultCount.textContent = String(count);
    if (noResults) noResults.classList.toggle("hidden", count > 0);
  }

  function updateMapMarkers(visibleSlugs) {
    if (!map || mapMarkerObjects.length === 0) return;
    mapMarkerObjects.forEach((marker) => {
      marker.getElement().classList.toggle("hidden", !visibleSlugs.has(marker._slug));
    });
  }

  function getPopupHtml(slug) {
    const template = popupTemplates?.querySelector(`template[data-slug="${slug}"]`);
    return template ? template.innerHTML : "";
  }

  async function initMap() {
    if (map) return;
    const maplibregl = window.maplibregl;
    map = new maplibregl.Map({
      container: mapHost,
      zoom: 10,
      center: [115.86, -31.95],
      maxPitch: 85,
      style: "https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json",
      attributionControl: false,
    });
    map.addControl(new maplibregl.AttributionControl({ compact: true }));
    map.on("style.load", () => map.setProjection({ type: "globe" }));
    map.on("load", () => {
      const attrib = mapHost.querySelector(".maplibregl-ctrl-attrib");
      if (attrib) attrib.removeAttribute("open");
    });
    markers.forEach((m) => {
      const el = document.createElement("div");
      el.className = "map-marker";
      const popup = new maplibregl.Popup({ offset: 15, maxWidth: "260px" }).setHTML(getPopupHtml(m.slug));
      const marker = new maplibregl.Marker({ element: el }).setLngLat(m.coords).setPopup(popup).addTo(map);
      marker._slug = m.slug;
      mapMarkerObjects.push(marker);
    });
  }

  function showCards() {
    grid?.classList.remove("hidden");
    mapHost?.classList.add("hidden");
  }

  function showMap() {
    grid?.classList.add("hidden");
    mapHost?.classList.remove("hidden");
    initMap().then(() => setTimeout(() => map?.resize(), 100));
  }

  // Expose for navbar
  window.showMap = showMap;
  window.showCards = showCards;

  // Load initial state from URL
  const urlQuery = getUrlQuery();
  if (urlQuery) {
    searchInput.value = urlQuery;
    doSearch(urlQuery, false);
  } else {
    const urlFilters = getUrlFilters();
    if (urlFilters.length > 0) applyFilters(urlFilters);
  }

  if (new URLSearchParams(window.location.search).get("view") === "map") {
    showMap();
  }
</script>
