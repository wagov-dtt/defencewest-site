---
import Layout from "../layouts/Layout.astro";
import CompanyCard from "../components/CompanyCard.astro";
import { getCollection } from "astro:content";
import { getTaxonomies, getStreamIcons } from "../lib/taxonomies";
import type { Company } from "../content.config";

// Load companies from Content Collection
const companyEntries = await getCollection("companies");
const companies: Company[] = companyEntries
  .map((entry) => entry.data)
  .sort((a, b) => a.name.localeCompare(b.name));

// Companies with coordinates for the map
const mappedCompanies = companies.filter((c) => c.latitude && c.longitude);

// Load taxonomies
const taxonomies = getTaxonomies();
const streamIcons = getStreamIcons();

// Count companies per taxonomy value
function countByTaxonomy(field: keyof Company): Map<string, number> {
  const counts = new Map<string, number>();
  companies.forEach((c) => {
    const values = (c[field] as string[] | undefined) || [];
    values.forEach((val: string) => {
      counts.set(val, (counts.get(val) || 0) + 1);
    });
  });
  return counts;
}

// Build filter sections config for cleaner template
const filterSections = [
  { 
    key: "capability_streams", 
    label: "Capability Streams", 
    items: Object.keys(taxonomies.capability_streams),
    counts: countByTaxonomy("capability_streams"),
    icons: streamIcons,
  },
  { 
    key: "stakeholders", 
    label: "Stakeholders", 
    items: taxonomies.stakeholders,
    counts: countByTaxonomy("stakeholders"),
  },
  { 
    key: "capability_domains", 
    label: "Domains", 
    items: taxonomies.capability_domains,
    counts: countByTaxonomy("capability_domains"),
  },
  { 
    key: "industrial_capabilities", 
    label: "Industrial", 
    items: taxonomies.industrial_capabilities,
    counts: countByTaxonomy("industrial_capabilities"),
  },
  { 
    key: "regions", 
    label: "Regions", 
    items: taxonomies.regions,
    counts: countByTaxonomy("regions"),
  },
];

// Count companies with boolean flags
const booleanFilters = [
  { key: "is_prime", label: "Prime Contractor", count: companies.filter(c => c.is_prime).length },
  { key: "is_sme", label: "SME", count: companies.filter(c => c.is_sme).length },
  { key: "is_indigenous_owned", label: "Indigenous Owned", count: companies.filter(c => c.is_indigenous_owned).length },
  { key: "is_veteran_owned", label: "Veteran Owned", count: companies.filter(c => c.is_veteran_owned).length },
].filter(f => f.count > 0);

// Prepare marker data for map (coordinates only, popup HTML is in DOM)
const markers = mappedCompanies.map((c) => ({
  slug: c.slug,
  name: c.name,
  coords: [c.longitude, c.latitude],
}));

// Prepare search data for companies
const searchData = companies.map((c) => ({
  slug: c.slug,
  name: c.name,
  overview: c.overview || "",
  capabilities: [
    ...(c.capability_streams || []),
    ...(c.capability_domains || []),
    ...(c.industrial_capabilities || []),
  ].join(" "),
}));

// Prepare filter suggestions (all taxonomy terms with counts)
const filterSuggestions = [
  // Boolean filters (Prime, SME, Indigenous, Veteran)
  ...booleanFilters.map(f => ({
    term: f.label,
    param: f.key,
    count: f.count,
    type: "boolean" as const,
  })),
  // Taxonomy filters
  ...filterSections.flatMap(section =>
    section.items.map((term: string) => ({
      term,
      param: section.key,
      count: section.counts.get(term) || 0,
      type: "taxonomy" as const,
    }))
  ),
].filter(s => s.count > 0);
---

<Layout title="WA Defence Industry and Science Capability Directory">
  <h1 class="visually-hidden">WA Defence Industry and Science Capability Directory</h1>
  <div class="directory-layout">
    <!-- Filters Sidebar -->
    <aside>
      <!-- Results Count & Active Filters -->
      <article class="filter-status-card">
        <p aria-live="polite" aria-atomic="true">
          <strong id="result-count">{companies.length}</strong> of {companies.length} companies
        </p>
        <div id="active-filters-container"></div>
      </article>

      <!-- Boolean Filters (Prime, SME, Ownership) -->
      {booleanFilters.length > 0 && (
        <details open>
          <summary>Company Type</summary>
          <ul>
            {booleanFilters.map(({ key, label, count }) => (
              <li>
                <a href={`/?${key}=true`}>
                  {label} <small>({count})</small>
                </a>
              </li>
            ))}
          </ul>
        </details>
      )}

      <!-- Taxonomy Filters -->
      {filterSections.map((section, idx) => {
        const hasIcons = section.icons;
        const visibleItems = section.items.filter((name: string) => (section.counts.get(name) || 0) > 0);
        if (visibleItems.length === 0) return null;
        
        return (
          <details open={idx === 0}>
            <summary>{section.label}</summary>
            {hasIcons ? (
              <div class="stream-icons">
                {visibleItems.map((name: string) => {
                  const icon = section.icons?.[name];
                  return icon ? (
                    <a href={`/?${section.key}=${encodeURIComponent(name)}`} title={name}>
                      <img src={icon as string} alt={name} loading="lazy" />
                    </a>
                  ) : null;
                })}
              </div>
            ) : (
              <ul>
                {visibleItems.map((name: string) => (
                  <li>
                    <a href={`/?${section.key}=${encodeURIComponent(name)}`}>
                      {name} <small>({section.counts.get(name)})</small>
                    </a>
                  </li>
                ))}
              </ul>
            )}
          </details>
        );
      })}
    </aside>

    <!-- Main Content -->
    <main>
      <label for="search-input" class="visually-hidden">Search companies</label>
      <input id="search-input" type="search" placeholder="Search companies..." autocomplete="off" />

      <div id="company-grid" class="company-grid">
        {
          companies.map((company) => (
            <div
              class="company-item"
              data-slug={company.slug}
              data-stakeholders={JSON.stringify(company.stakeholders || [])}
              data-capability-streams={JSON.stringify(
                company.capability_streams || [],
              )}
              data-capability-domains={JSON.stringify(
                company.capability_domains || [],
              )}
              data-industrial-capabilities={JSON.stringify(
                company.industrial_capabilities || [],
              )}
              data-regions={JSON.stringify(company.regions || [])}
              data-is-prime={company.is_prime || false}
              data-is-sme={company.is_sme || false}
              data-is-indigenous-owned={company.is_indigenous_owned || false}
              data-is-veteran-owned={company.is_veteran_owned || false}
            >
              <CompanyCard company={company} />
            </div>
          ))
        }
      </div>

      <div id="map-host" class="hidden" role="application" aria-label="Interactive company location map"></div>
      <p id="no-results" class="hidden">
        No companies match your search criteria.
      </p>
    </main>
  </div>

  <!-- Pre-rendered map popups (hidden, cloned by JS) -->
  <div id="map-popups" style="display: none;">
    {
      mappedCompanies.map((company) => (
        <template data-slug={company.slug}>
          <CompanyCard company={company} compact />
        </template>
      ))
    }
  </div>

  <!-- Anchor for map navigation -->
  <div id="map"></div>
</Layout>

<script type="module" define:vars={{ markers, searchData, filterSuggestions }}>
  import autoComplete from "https://esm.sh/@tarekraafat/autocomplete.js@10";
  import uFuzzy from "https://esm.sh/@leeoniya/ufuzzy@1";

  window.mapMarkers = markers;

  const grid = document.getElementById("company-grid");
  const mapHost = document.getElementById("map-host");
  const resultCount = document.getElementById("result-count");
  const noResults = document.getElementById("no-results");
  const popupTemplates = document.getElementById("map-popups");
  const allCards = Array.from(document.querySelectorAll(".company-item"));
  const searchInput = document.getElementById("search-input");

  // Taxonomy filter map: URL param -> data attribute
  const taxonomyMap = {
    stakeholders: "stakeholders",
    capability_streams: "capabilityStreams",
    capability_domains: "capabilityDomains",
    industrial_capabilities: "industrialCapabilities",
    regions: "regions",
  };

  // Boolean filter map: URL param -> data attribute
  const booleanFilterMap = {
    is_prime: "isPrime",
    is_sme: "isSme",
    is_indigenous_owned: "isIndigenousOwned",
    is_veteran_owned: "isVeteranOwned",
  };

  // Initialize uFuzzy for company search (with typo tolerance)
  const uf = new uFuzzy({ intraMode: 1 });
  const searchStrings = searchData.map(d => 
    `${d.name} ${d.overview} ${d.capabilities}`.toLowerCase()
  );

  // Initialize uFuzzy for filter suggestions (with typo tolerance)
  const ufFilters = new uFuzzy({ intraMode: 1 });
  const filterStrings = filterSuggestions.map(s => s.term.toLowerCase());

  // Map state
  let map = null;
  let mapMarkerObjects = [];

  // Track current filter matches for autocomplete
  let currentFilterMatches = [];

  // Initialize autoComplete.js for filter term suggestions
  new autoComplete({
    selector: "#search-input",
    data: {
      src: () => currentFilterMatches,
      keys: ["term"],
    },
    searchEngine: (query, record) => {
      // Just return the term - filtering is done in data.src
      return record;
    },
    resultItem: {
      element: (item, data) => {
        item.innerHTML = `<span>${data.value.term}</span> <small>(${data.value.count})</small>`;
      },
    },
    events: {
      input: {
        focus: () => {
          // Update matches on focus too
          const query = searchInput.value;
          if (query && query.length >= 2) {
            const [idxs] = ufFilters.search(filterStrings, query.toLowerCase());
            currentFilterMatches = idxs ? idxs.slice(0, 8).map(i => filterSuggestions[i]) : [];
          }
        },
        selection: (event) => {
          const selection = event.detail.selection.value;
          // Apply as filter
          searchInput.value = "";
          searchInput.blur();
          const isBool = selection.type === "boolean";
          const dataAttr = isBool ? booleanFilterMap[selection.param] : taxonomyMap[selection.param];
          const newFilter = { 
            param: selection.param, 
            dataAttr, 
            value: isBool ? selection.term : selection.term, 
            type: selection.type 
          };
          const currentFilters = getUrlFilters();
          const exists = currentFilters.some(f => f.param === newFilter.param && f.value === newFilter.value);
          if (!exists) currentFilters.push(newFilter);
          updateUrl(currentFilters);
          applyFilters(currentFilters);
        },
      },
    },
  });

  // Also filter grid on input and update autocomplete matches
  let debounceTimer;
  searchInput.addEventListener("input", () => {
    const query = searchInput.value;
    // Update filter matches for autocomplete
    if (query && query.length >= 2) {
      const [idxs] = ufFilters.search(filterStrings, query.toLowerCase());
      currentFilterMatches = idxs ? idxs.slice(0, 8).map(i => filterSuggestions[i]) : [];
    } else {
      currentFilterMatches = [];
    }
    // Debounce the grid filtering
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => doSearch(query), 150);
  });

  // URL helpers
  function getUrlFilters() {
    const params = new URLSearchParams(window.location.search);
    const filters = [];
    // Taxonomy filters (arrays)
    for (const [param, dataAttr] of Object.entries(taxonomyMap)) {
      const values = params.getAll(param);
      values.forEach((value) => {
        if (value) filters.push({ param, dataAttr, value, type: "taxonomy" });
      });
    }
    // Boolean filters
    for (const [param, dataAttr] of Object.entries(booleanFilterMap)) {
      if (params.get(param) === "true") {
        filters.push({ param, dataAttr, value: param.replace("is_", "").replace("_", " "), type: "boolean" });
      }
    }
    return filters;
  }

  function getUrlQuery() {
    return new URLSearchParams(window.location.search).get("q") || "";
  }

  function updateUrl(filters, query = "") {
    const params = new URLSearchParams();
    if (query) params.set("q", query);
    filters.forEach((f) => {
      if (f.type === "boolean") {
        params.set(f.param, "true");
      } else {
        params.append(f.param, f.value);
      }
    });
    const newUrl = params.toString()
      ? `${window.location.pathname}?${params.toString()}`
      : window.location.pathname;
    window.history.pushState({}, "", newUrl);
  }

  // Highlighting
  function highlightText(text, query) {
    if (!query || query.length < 2) return text;
    const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")})`, "gi");
    return text.replace(regex, "<mark>$1</mark>");
  }

  function clearHighlights() {
    allCards.forEach((card) => {
      const nameEl = card.querySelector("h4");
      const overviewEl = card.querySelector("p");
      if (nameEl?.dataset.original) nameEl.innerHTML = nameEl.dataset.original;
      if (overviewEl?.dataset.original) overviewEl.innerHTML = overviewEl.dataset.original;
    });
  }

  function applyHighlights(query, matchingSlugs) {
    if (!query || query.length < 2) {
      clearHighlights();
      return;
    }
    allCards.forEach((card) => {
      const slug = card.dataset.slug;
      const nameEl = card.querySelector("h4");
      const overviewEl = card.querySelector("p");
      if (nameEl && !nameEl.dataset.original) nameEl.dataset.original = nameEl.textContent;
      if (overviewEl && !overviewEl.dataset.original) overviewEl.dataset.original = overviewEl.textContent;
      if (matchingSlugs.has(slug)) {
        if (nameEl) nameEl.innerHTML = highlightText(nameEl.dataset.original, query);
        if (overviewEl) overviewEl.innerHTML = highlightText(overviewEl.dataset.original, query);
      } else {
        if (nameEl) nameEl.innerHTML = nameEl.dataset.original;
        if (overviewEl) overviewEl.innerHTML = overviewEl.dataset.original;
      }
    });
  }

  // Filtering
  function applyFilters(filters) {
    clearHighlights();
    if (filters.length === 0) {
      allCards.forEach((card) => card.classList.remove("hidden"));
      updateResultCount(allCards.length);
      updateMapMarkers(new Set(allCards.map((c) => c.dataset.slug)));
      updateFilterDisplay(filters);
      return;
    }
    let visibleCount = 0;
    const visibleSlugs = new Set();
    allCards.forEach((card) => {
      const matches = filters.every((filter) => {
        if (filter.type === "boolean") {
          return card.dataset[filter.dataAttr] === "true";
        }
        const values = JSON.parse(card.dataset[filter.dataAttr] || "[]");
        return values.includes(filter.value);
      });
      card.classList.toggle("hidden", !matches);
      if (matches) {
        visibleCount++;
        visibleSlugs.add(card.dataset.slug);
      }
    });
    updateResultCount(visibleCount);
    updateMapMarkers(visibleSlugs);
    updateFilterDisplay(filters);
  }

  function updateFilterDisplay(filters) {
    const filterContainer = document.getElementById("active-filters-container");
    if (!filterContainer) return;
    if (filters.length > 0) {
      filterContainer.innerHTML =
        filters.map((f, i) => `<button type="button" class="filter-tag" data-index="${i}">${f.value} <span aria-hidden="true">Ã—</span><span class="visually-hidden">Remove filter</span></button>`).join("") +
        `<a href="#" id="clear-all-filters" class="secondary">Clear all</a>`;
      filterContainer.querySelectorAll("button[data-index]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const newFilters = filters.filter((_, i) => i !== parseInt(btn.dataset.index));
          updateUrl(newFilters);
          applyFilters(newFilters);
        });
      });
      document.getElementById("clear-all-filters")?.addEventListener("click", (e) => {
        e.preventDefault();
        updateUrl([]);
        applyFilters([]);
      });
    } else {
      filterContainer.innerHTML = "";
    }
  }

  // Filter link clicks
  document.querySelectorAll('aside a[href*="?"]').forEach((link) => {
    link.addEventListener("click", (e) => {
      e.preventDefault();
      const href = link.getAttribute("href");
      const linkParams = new URLSearchParams(href.split("?")[1] || "");
      let newFilter = null;
      // Check taxonomy filters
      for (const [param, dataAttr] of Object.entries(taxonomyMap)) {
        const value = linkParams.get(param);
        if (value) {
          newFilter = { param, dataAttr, value, type: "taxonomy" };
          break;
        }
      }
      // Check boolean filters
      if (!newFilter) {
        for (const [param, dataAttr] of Object.entries(booleanFilterMap)) {
          if (linkParams.get(param) === "true") {
            newFilter = { param, dataAttr, value: param.replace("is_", "").replace(/_/g, " "), type: "boolean" };
            break;
          }
        }
      }
      if (newFilter) {
        searchInput.value = "";
        clearHighlights();
        const currentFilters = getUrlFilters();
        const exists = currentFilters.some((f) => f.param === newFilter.param && f.value === newFilter.value);
        if (!exists) currentFilters.push(newFilter);
        updateUrl(currentFilters);
        applyFilters(currentFilters);
      }
    });
  });

  // Search
  function doSearch(query, updateHistory = true) {
    if (query.trim() && updateHistory) {
      updateUrl([], query);
      updateFilterDisplay([]);
    } else if (!query.trim() && updateHistory) {
      updateUrl([]);
    }
    if (!query.trim()) {
      clearHighlights();
      const filters = getUrlFilters();
      if (filters.length > 0) {
        applyFilters(filters);
        return;
      }
      allCards.forEach((card) => card.classList.remove("hidden"));
      updateResultCount(allCards.length);
      updateMapMarkers(new Set(allCards.map((c) => c.dataset.slug)));
      return;
    }
    // Use uFuzzy for grid filtering too
    const [idxs] = uf.search(searchStrings, query.toLowerCase());
    const matchingSlugs = new Set(idxs ? idxs.map(i => searchData[i].slug) : []);
    allCards.forEach((card) => {
      card.classList.toggle("hidden", !matchingSlugs.has(card.dataset.slug));
    });
    applyHighlights(query, matchingSlugs);
    updateResultCount(matchingSlugs.size);
    updateMapMarkers(matchingSlugs);
  }

  function updateResultCount(count) {
    if (resultCount) resultCount.textContent = String(count);
    if (noResults) noResults.classList.toggle("hidden", count > 0);
  }

  function updateMapMarkers(visibleSlugs) {
    if (!map || mapMarkerObjects.length === 0) return;
    mapMarkerObjects.forEach((marker) => {
      marker.getElement().classList.toggle("hidden", !visibleSlugs.has(marker._slug));
    });
  }

  function getPopupHtml(slug) {
    const template = popupTemplates?.querySelector(`template[data-slug="${slug}"]`);
    return template ? template.innerHTML : "";
  }

  async function initMap() {
    if (map) return;
    const maplibregl = window.maplibregl;
    map = new maplibregl.Map({
      container: mapHost,
      zoom: 10,
      center: [115.86, -31.95],
      maxPitch: 85,
      style: "https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json",
      attributionControl: false,
    });
    map.addControl(new maplibregl.AttributionControl({ compact: true }));
    map.on("style.load", () => map.setProjection({ type: "globe" }));
    map.on("load", () => {
      const attrib = mapHost.querySelector(".maplibregl-ctrl-attrib");
      if (attrib) attrib.removeAttribute("open");
    });
    let activePopupMarker = null;
    
    markers.forEach((m) => {
      const el = document.createElement("button");
      el.className = "map-marker";
      el.type = "button";
      el.setAttribute("aria-label", `View ${m.name} on map`);
      const popup = new maplibregl.Popup({ offset: 15, maxWidth: "260px", closeButton: true }).setHTML(getPopupHtml(m.slug));
      const marker = new maplibregl.Marker({ element: el }).setLngLat(m.coords).setPopup(popup).addTo(map);
      marker._slug = m.slug;
      mapMarkerObjects.push(marker);
      
      // Show popup on hover or focus
      function openPopup() {
        if (activePopupMarker && activePopupMarker !== marker) {
          activePopupMarker.getPopup().remove();
        }
        if (!marker.getPopup().isOpen()) {
          marker.togglePopup();
        }
        activePopupMarker = marker;
      }
      el.addEventListener("mouseenter", openPopup);
      el.addEventListener("focus", openPopup);
      
      // Click toggles popup (close if open, open if closed)
      el.addEventListener("click", (e) => {
        e.stopPropagation();
        if (marker.getPopup().isOpen()) {
          marker.getPopup().remove();
          activePopupMarker = null;
        } else {
          openPopup();
        }
      });
    });
  }

  function showCards() {
    grid?.classList.remove("hidden");
    mapHost?.classList.add("hidden");
  }

  function showMap() {
    grid?.classList.add("hidden");
    mapHost?.classList.remove("hidden");
    initMap().then(() => setTimeout(() => map?.resize(), 100));
  }

  // Expose for navbar
  window.showMap = showMap;
  window.showCards = showCards;

  // Load initial state from URL
  const urlQuery = getUrlQuery();
  if (urlQuery) {
    searchInput.value = urlQuery;
    doSearch(urlQuery, false);
  } else {
    const urlFilters = getUrlFilters();
    if (urlFilters.length > 0) applyFilters(urlFilters);
  }

  if (new URLSearchParams(window.location.search).get("view") === "map") {
    showMap();
  }
</script>
